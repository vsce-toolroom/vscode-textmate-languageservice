// Generated by peggy v. 2.0.1 (ts-pegjs plugin v. 3.0.0 )
//
// https://peggyjs.org/   https://github.com/metadevpro/ts-pegjs

'use strict';

import matchers = require('./matchers');

export interface FilePosition {
	offset: number;
	line: number;
	column: number;
}

export interface FileRange {
	start: FilePosition;
	end: FilePosition;
	source: string;
}

export interface LiteralExpectation {
	type: 'literal';
	text: string;
	ignoreCase: boolean;
}

export interface ClassParts extends Array<string | ClassParts> {}

export interface ClassExpectation {
	type: 'class';
	parts: ClassParts;
	inverted: boolean;
	ignoreCase: boolean;
}

export interface AnyExpectation {
	type: 'any';
}

export interface EndExpectation {
	type: 'end';
}

export interface OtherExpectation {
	type: 'other';
	description: string;
}

export type Expectation = LiteralExpectation | ClassExpectation | AnyExpectation | EndExpectation | OtherExpectation;

function peg$padEnd(str: string, targetLength: number, padString: string) {
	padString = padString || ' ';
	if (str.length > targetLength) {
		return str;
	}
	targetLength -= str.length;
	padString += padString.repeat(targetLength);
	return str + padString.slice(0, targetLength);
}

export class PeggySyntaxError extends Error {
	public static buildMessage(expected: Expectation[], found: string | null) {
		function hex(ch: string): string {
			return ch.charCodeAt(0).toString(16).toUpperCase();
		}

		function literalEscape(s: string): string {
			return s
				.replace(/\\/g, '\\\\')
				.replace(/"/g, '\\"')
				.replace(/\0/g, '\\0')
				.replace(/\t/g, '\\t')
				.replace(/\n/g, '\\n')
				.replace(/\r/g, '\\r')
				.replace(/[\x00-\x0F]/g, ch => '\\x0' + hex(ch))
				.replace(/[\x10-\x1F\x7F-\x9F]/g, ch => '\\x' + hex(ch));
		}

		function classEscape(s: string): string {
			return s
				.replace(/\\/g, '\\\\')
				.replace(/\]/g, '\\]')
				.replace(/\^/g, '\\^')
				.replace(/-/g, '\\-')
				.replace(/\0/g, '\\0')
				.replace(/\t/g, '\\t')
				.replace(/\n/g, '\\n')
				.replace(/\r/g, '\\r')
				.replace(/[\x00-\x0F]/g, ch => '\\x0' + hex(ch))
				.replace(/[\x10-\x1F\x7F-\x9F]/g, ch => '\\x' + hex(ch));
		}

		function describeExpectation(expectation: Expectation) {
			switch (expectation.type) {
				case 'literal':
					return '"' + literalEscape(expectation.text) + '"';
				case 'class':
					const escapedParts = expectation.parts.map(part => {
						return Array.isArray(part)
							? classEscape(part[0] as string) + '-' + classEscape(part[1] as string)
							: classEscape(part);
					});

					return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']';
				case 'any':
					return 'any character';
				case 'end':
					return 'end of input';
				case 'other':
					return expectation.description;
			}
		}

		function describeExpected(expected1: Expectation[]) {
			const descriptions = expected1.map(describeExpectation);
			let i: number;
			let j: number;

			descriptions.sort();

			if (descriptions.length > 0) {
				for (i = 1, j = 1; i < descriptions.length; i++) {
					if (descriptions[i - 1] !== descriptions[i]) {
						descriptions[j] = descriptions[i];
						j++;
					}
				}
				descriptions.length = j;
			}

			switch (descriptions.length) {
				case 1:
					return descriptions[0];

				case 2:
					return descriptions[0] + ' or ' + descriptions[1];

				default:
					return descriptions.slice(0, -1).join(', ') + ', or ' + descriptions[descriptions.length - 1];
			}
		}

		function describeFound(found1: string | null) {
			return found1 ? '"' + literalEscape(found1) + '"' : 'end of input';
		}

		return 'Expected ' + describeExpected(expected) + ' but ' + describeFound(found) + ' found.';
	}

	public message: string;
	public expected: Expectation[];
	public found: string | null;
	public location: FileRange;
	public name: string;

	constructor(message: string, expected: Expectation[], found: string | null, location: FileRange) {
		super();
		this.message = message;
		this.expected = expected;
		this.found = found;
		this.location = location;
		this.name = 'PeggySyntaxError';

		if (typeof (Object as any).setPrototypeOf === 'function') {
			(Object as any).setPrototypeOf(this, PeggySyntaxError.prototype);
		} else {
			(this as any).__proto__ = PeggySyntaxError.prototype;
		}
		if (typeof (Error as any).captureStackTrace === 'function') {
			(Error as any).captureStackTrace(this, PeggySyntaxError);
		}
	}

	format(sources: { grammarSource?: string; text: string }[]): string {
		let str = 'Error: ' + this.message;
		if (this.location) {
			let src: string[] | null = null;
			let k;
			for (k = 0; k < sources.length; k++) {
				if (sources[k].grammarSource === this.location.source) {
					src = sources[k].text.split(/\r\n|\n|\r/g);
					break;
				}
			}
			let s = this.location.start;
			let loc = this.location.source + ':' + s.line + ':' + s.column;
			if (src) {
				let e = this.location.end;
				let filler = peg$padEnd('', s.line.toString().length, ' ');
				let line = src[s.line - 1];
				let last = s.line === e.line ? e.column : line.length + 1;
				str +=
					'\n --> ' +
					loc +
					'\n' +
					filler +
					' |\n' +
					s.line +
					' | ' +
					line +
					'\n' +
					filler +
					' | ' +
					peg$padEnd('', s.column - 1, ' ') +
					peg$padEnd('', last - s.column, '^');
			} else {
				str += '\n at ' + loc;
			}
		}
		return str;
	}
}

function peg$parse(input: string, options?: ParseOptions) {
	options = options !== undefined ? options : {};

	const peg$FAILED: Readonly<any> = {};
	const peg$source = options.grammarSource;

	const peg$startRuleFunctions: { [id: string]: any } = { start: peg$parsestart };
	let peg$startRuleFunction: () => any = peg$parsestart;

	const peg$c0 = function (selector: any): any {
		return selector;
	};
	const peg$c1 = /^[a-zA-Z0-9+_]/;
	const peg$c2 = peg$classExpectation([['a', 'z'], ['A', 'Z'], ['0', '9'], '+', '_'], false, false);
	const peg$c3 = /^[a-zA-Z0-9\-+_]/;
	const peg$c4 = peg$classExpectation([['a', 'z'], ['A', 'Z'], ['0', '9'], '-', '+', '_'], false, false);
	const peg$c5 = function (segment: any): any {
		return new matchers.SegmentMatcher(segment);
	};
	const peg$c6 = /^[*]/;
	const peg$c7 = peg$classExpectation(['*'], false, false);
	const peg$c8 = function (asterisk: any): any {
		return new matchers.TrueMatcher();
	};
	const peg$c9 = '.';
	const peg$c10 = peg$literalExpectation('.', false);
	const peg$c11 = function (first: any, others: any): any {
		return new matchers.ScopeMatcher(first, others);
	};
	const peg$c12 = /^[LRB]/;
	const peg$c13 = peg$classExpectation(['L', 'R', 'B'], false, false);
	const peg$c14 = ':';
	const peg$c15 = peg$literalExpectation(':', false);
	const peg$c16 = function (prefix: any, first: any, others: any): any {
		return new matchers.PathMatcher(prefix, first, others);
	};
	const peg$c17 = '(';
	const peg$c18 = peg$literalExpectation('(', false);
	const peg$c19 = ')';
	const peg$c20 = peg$literalExpectation(')', false);
	const peg$c21 = function (prefix: any, selector: any): any {
		return new matchers.GroupMatcher(prefix, selector);
	};
	const peg$c22 = '-';
	const peg$c23 = peg$literalExpectation('-', false);
	const peg$c24 = function (group: any): any {
		return new matchers.NegateMatcher(group);
	};
	const peg$c25 = function (path: any): any {
		return new matchers.NegateMatcher(path);
	};
	const peg$c26 = /^[|&\-]/;
	const peg$c27 = peg$classExpectation(['|', '&', '-'], false, false);
	const peg$c28 = function (left: any, operator: any, right: any): any {
		return new matchers.CompositeMatcher(left, operator, right);
	};
	const peg$c29 = ',';
	const peg$c30 = peg$literalExpectation(',', false);
	const peg$c31 = function (left: any, right: any): any {
		if (right) return new matchers.OrMatcher(left, right);
		else return left;
	};
	const peg$c32 = /^[ \t]/;
	const peg$c33 = peg$classExpectation([' ', '\t'], false, false);

	let peg$currPos = 0;
	let peg$savedPos = 0;
	const peg$posDetailsCache = [{ line: 1, column: 1 }];
	let peg$maxFailPos = 0;
	let peg$maxFailExpected: Expectation[] = [];
	let peg$silentFails = 0;

	let peg$result;

	if (options.startRule !== undefined) {
		if (!(options.startRule in peg$startRuleFunctions)) {
			throw new Error('Can\'t start parsing from rule "' + options.startRule + '".');
		}

		peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	}

	function text(): string {
		return input.substring(peg$savedPos, peg$currPos);
	}

	function location(): FileRange {
		return peg$computeLocation(peg$savedPos, peg$currPos);
	}

	function expected(description: string, location1?: FileRange) {
		location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);

		throw peg$buildStructuredError(
			[peg$otherExpectation(description)],
			input.substring(peg$savedPos, peg$currPos),
			location1
		);
	}

	function error(message: string, location1?: FileRange) {
		location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);

		throw peg$buildSimpleError(message, location1);
	}

	function peg$literalExpectation(text1: string, ignoreCase: boolean): LiteralExpectation {
		return { type: 'literal', text: text1, ignoreCase: ignoreCase };
	}

	function peg$classExpectation(parts: ClassParts, inverted: boolean, ignoreCase: boolean): ClassExpectation {
		return { type: 'class', parts: parts, inverted: inverted, ignoreCase: ignoreCase };
	}

	function peg$anyExpectation(): AnyExpectation {
		return { type: 'any' };
	}

	function peg$endExpectation(): EndExpectation {
		return { type: 'end' };
	}

	function peg$otherExpectation(description: string): OtherExpectation {
		return { type: 'other', description: description };
	}

	function peg$computePosDetails(pos: number) {
		let details = peg$posDetailsCache[pos];
		let p;

		if (details) {
			return details;
		} else {
			p = pos - 1;
			while (!peg$posDetailsCache[p]) {
				p--;
			}

			details = peg$posDetailsCache[p];
			details = {
				line: details.line,
				column: details.column
			};

			while (p < pos) {
				if (input.charCodeAt(p) === 10) {
					details.line++;
					details.column = 1;
				} else {
					details.column++;
				}

				p++;
			}

			peg$posDetailsCache[pos] = details;

			return details;
		}
	}

	function peg$computeLocation(startPos: number, endPos: number): FileRange {
		const startPosDetails = peg$computePosDetails(startPos);
		const endPosDetails = peg$computePosDetails(endPos);

		return {
			source: peg$source,
			start: {
				offset: startPos,
				line: startPosDetails.line,
				column: startPosDetails.column
			},
			end: {
				offset: endPos,
				line: endPosDetails.line,
				column: endPosDetails.column
			}
		};
	}

	function peg$fail(expected1: Expectation) {
		if (peg$currPos < peg$maxFailPos) {
			return;
		}

		if (peg$currPos > peg$maxFailPos) {
			peg$maxFailPos = peg$currPos;
			peg$maxFailExpected = [];
		}

		peg$maxFailExpected.push(expected1);
	}

	function peg$buildSimpleError(message: string, location1: FileRange) {
		return new PeggySyntaxError(message, [], '', location1);
	}

	function peg$buildStructuredError(expected1: Expectation[], found: string | null, location1: FileRange) {
		return new PeggySyntaxError(PeggySyntaxError.buildMessage(expected1, found), expected1, found, location1);
	}

	function peg$parsestart(): matchers.ParsedMatcher {
		let s0, s1, s2, s3;

		s0 = peg$currPos;
		s1 = peg$parse_();
		if ((s1 as any) !== peg$FAILED) {
			s2 = peg$parseselector();
			if ((s2 as any) !== peg$FAILED) {
				s3 = peg$parse_();
				if ((s3 as any) !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c0(s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parseatom(): matchers.AtomMatcher {
		let s0, s1, s2, s3, s4, s5;

		s0 = peg$currPos;
		s1 = peg$parse_();
		if ((s1 as any) !== peg$FAILED) {
			s2 = peg$currPos;
			s3 = [];
			if (peg$c1.test(input.charAt(peg$currPos))) {
				s4 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s4 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c2);
				}
			}
			if ((s4 as any) !== peg$FAILED) {
				while ((s4 as any) !== peg$FAILED) {
					s3.push(s4);
					if (peg$c1.test(input.charAt(peg$currPos))) {
						s4 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s4 = peg$FAILED;
						if (peg$silentFails === 0) {
							peg$fail(peg$c2);
						}
					}
				}
			} else {
				s3 = peg$FAILED;
			}
			if ((s3 as any) !== peg$FAILED) {
				s4 = [];
				if (peg$c3.test(input.charAt(peg$currPos))) {
					s5 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) {
						peg$fail(peg$c4);
					}
				}
				while ((s5 as any) !== peg$FAILED) {
					s4.push(s5);
					if (peg$c3.test(input.charAt(peg$currPos))) {
						s5 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s5 = peg$FAILED;
						if (peg$silentFails === 0) {
							peg$fail(peg$c4);
						}
					}
				}
				if ((s4 as any) !== peg$FAILED) {
					s3 = [s3, s4];
					s2 = s3;
				} else {
					peg$currPos = s2;
					s2 = peg$FAILED;
				}
			} else {
				peg$currPos = s2;
				s2 = peg$FAILED;
			}
			if ((s2 as any) !== peg$FAILED) {
				s3 = peg$parse_();
				if ((s3 as any) !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c5(s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		if ((s0 as any) === peg$FAILED) {
			s0 = peg$currPos;
			s1 = peg$parse_();
			if ((s1 as any) !== peg$FAILED) {
				if (peg$c6.test(input.charAt(peg$currPos))) {
					s2 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) {
						peg$fail(peg$c7);
					}
				}
				if ((s2 as any) !== peg$FAILED) {
					s3 = peg$parse_();
					if ((s3 as any) !== peg$FAILED) {
						peg$savedPos = s0;
						s1 = peg$c8(s2);
						s0 = s1;
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		}

		return s0;
	}

	function peg$parsescope(): matchers.ScopeMatcher {
		let s0, s1, s2, s3, s4, s5;

		s0 = peg$currPos;
		s1 = peg$parseatom();
		if ((s1 as any) !== peg$FAILED) {
			s2 = [];
			s3 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 46) {
				s4 = peg$c9;
				peg$currPos++;
			} else {
				s4 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c10);
				}
			}
			if ((s4 as any) !== peg$FAILED) {
				s5 = peg$parseatom();
				if ((s5 as any) !== peg$FAILED) {
					s4 = [s4, s5];
					s3 = s4;
				} else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
			} else {
				peg$currPos = s3;
				s3 = peg$FAILED;
			}
			while ((s3 as any) !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$currPos;
				if (input.charCodeAt(peg$currPos) === 46) {
					s4 = peg$c9;
					peg$currPos++;
				} else {
					s4 = peg$FAILED;
					if (peg$silentFails === 0) {
						peg$fail(peg$c10);
					}
				}
				if ((s4 as any) !== peg$FAILED) {
					s5 = peg$parseatom();
					if ((s5 as any) !== peg$FAILED) {
						s4 = [s4, s5];
						s3 = s4;
					} else {
						peg$currPos = s3;
						s3 = peg$FAILED;
					}
				} else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
			}
			if ((s2 as any) !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c11(s1, s2);
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parsepath(): matchers.PathMatcher {
		let s0, s1, s2, s3, s4, s5, s6;

		s0 = peg$currPos;
		s1 = peg$currPos;
		if (peg$c12.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) {
				peg$fail(peg$c13);
			}
		}
		if ((s2 as any) !== peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 58) {
				s3 = peg$c14;
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c15);
				}
			}
			if ((s3 as any) !== peg$FAILED) {
				s2 = [s2, s3];
				s1 = s2;
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
		} else {
			peg$currPos = s1;
			s1 = peg$FAILED;
		}
		if ((s1 as any) === peg$FAILED) {
			s1 = null;
		}
		if ((s1 as any) !== peg$FAILED) {
			s2 = peg$parsescope();
			if ((s2 as any) !== peg$FAILED) {
				s3 = [];
				s4 = peg$currPos;
				s5 = peg$parse_();
				if ((s5 as any) !== peg$FAILED) {
					s6 = peg$parsescope();
					if ((s6 as any) !== peg$FAILED) {
						s5 = [s5, s6];
						s4 = s5;
					} else {
						peg$currPos = s4;
						s4 = peg$FAILED;
					}
				} else {
					peg$currPos = s4;
					s4 = peg$FAILED;
				}
				while ((s4 as any) !== peg$FAILED) {
					s3.push(s4);
					s4 = peg$currPos;
					s5 = peg$parse_();
					if ((s5 as any) !== peg$FAILED) {
						s6 = peg$parsescope();
						if ((s6 as any) !== peg$FAILED) {
							s5 = [s5, s6];
							s4 = s5;
						} else {
							peg$currPos = s4;
							s4 = peg$FAILED;
						}
					} else {
						peg$currPos = s4;
						s4 = peg$FAILED;
					}
				}
				if ((s3 as any) !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c16(s1, s2, s3);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parsegroup(): matchers.GroupMatcher {
		let s0, s1, s2, s3, s4, s5, s6;

		s0 = peg$currPos;
		s1 = peg$currPos;
		if (peg$c12.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) {
				peg$fail(peg$c13);
			}
		}
		if ((s2 as any) !== peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 58) {
				s3 = peg$c14;
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c15);
				}
			}
			if ((s3 as any) !== peg$FAILED) {
				s2 = [s2, s3];
				s1 = s2;
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
		} else {
			peg$currPos = s1;
			s1 = peg$FAILED;
		}
		if ((s1 as any) === peg$FAILED) {
			s1 = null;
		}
		if ((s1 as any) !== peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 40) {
				s2 = peg$c17;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c18);
				}
			}
			if ((s2 as any) !== peg$FAILED) {
				s3 = peg$parse_();
				if ((s3 as any) !== peg$FAILED) {
					s4 = peg$parseselector();
					if ((s4 as any) !== peg$FAILED) {
						s5 = peg$parse_();
						if ((s5 as any) !== peg$FAILED) {
							if (input.charCodeAt(peg$currPos) === 41) {
								s6 = peg$c19;
								peg$currPos++;
							} else {
								s6 = peg$FAILED;
								if (peg$silentFails === 0) {
									peg$fail(peg$c20);
								}
							}
							if ((s6 as any) !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c21(s1, s4);
								s0 = s1;
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parseexpression(): matchers.NegateMatcher | matchers.GroupMatcher | matchers.PathMatcher {
		let s0, s1, s2, s3, s4;

		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 45) {
			s1 = peg$c22;
			peg$currPos++;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) {
				peg$fail(peg$c23);
			}
		}
		if ((s1 as any) !== peg$FAILED) {
			s2 = peg$parse_();
			if ((s2 as any) !== peg$FAILED) {
				s3 = peg$parsegroup();
				if ((s3 as any) !== peg$FAILED) {
					s4 = peg$parse_();
					if ((s4 as any) !== peg$FAILED) {
						peg$savedPos = s0;
						s1 = peg$c24(s3);
						s0 = s1;
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		if ((s0 as any) === peg$FAILED) {
			s0 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 45) {
				s1 = peg$c22;
				peg$currPos++;
			} else {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c23);
				}
			}
			if ((s1 as any) !== peg$FAILED) {
				s2 = peg$parse_();
				if ((s2 as any) !== peg$FAILED) {
					s3 = peg$parsepath();
					if ((s3 as any) !== peg$FAILED) {
						s4 = peg$parse_();
						if ((s4 as any) !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c25(s3);
							s0 = s1;
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
			if ((s0 as any) === peg$FAILED) {
				s0 = peg$parsegroup();
				if ((s0 as any) === peg$FAILED) {
					s0 = peg$parsepath();
				}
			}
		}

		return s0;
	}

	function peg$parsecomposite():
		| matchers.GroupMatcher
		| matchers.NegateMatcher
		| matchers.GroupMatcher
		| matchers.PathMatcher {
		let s0, s1, s2, s3, s4, s5;

		s0 = peg$currPos;
		s1 = peg$parseexpression();
		if ((s1 as any) !== peg$FAILED) {
			s2 = peg$parse_();
			if ((s2 as any) !== peg$FAILED) {
				if (peg$c26.test(input.charAt(peg$currPos))) {
					s3 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) {
						peg$fail(peg$c27);
					}
				}
				if ((s3 as any) !== peg$FAILED) {
					s4 = peg$parse_();
					if ((s4 as any) !== peg$FAILED) {
						s5 = peg$parsecomposite();
						if ((s5 as any) !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c28(s1, s3, s5);
							s0 = s1;
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		if ((s0 as any) === peg$FAILED) {
			s0 = peg$parseexpression();
		}

		return s0;
	}

	function peg$parseselector(): matchers.ParsedMatcher {
		let s0, s1, s2, s3, s4, s5;

		s0 = peg$currPos;
		s1 = peg$parsecomposite();
		if ((s1 as any) !== peg$FAILED) {
			s2 = peg$parse_();
			if ((s2 as any) !== peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 44) {
					s3 = peg$c29;
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) {
						peg$fail(peg$c30);
					}
				}
				if ((s3 as any) !== peg$FAILED) {
					s4 = peg$parse_();
					if ((s4 as any) !== peg$FAILED) {
						s5 = peg$parseselector();
						if ((s5 as any) === peg$FAILED) {
							s5 = null;
						}
						if ((s5 as any) !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c31(s1, s5);
							s0 = s1;
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		if ((s0 as any) === peg$FAILED) {
			s0 = peg$parsecomposite();
		}

		return s0;
	}

	function peg$parse_(): Array<' ' | '	'> {
		let s0, s1;

		s0 = [];
		if (peg$c32.test(input.charAt(peg$currPos))) {
			s1 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) {
				peg$fail(peg$c33);
			}
		}
		while ((s1 as any) !== peg$FAILED) {
			s0.push(s1);
			if (peg$c32.test(input.charAt(peg$currPos))) {
				s1 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c33);
				}
			}
		}

		return s0;
	}

	peg$result = peg$startRuleFunction();

	if (peg$result !== peg$FAILED && peg$currPos === input.length) {
		return peg$result;
	} else {
		if (peg$result !== peg$FAILED && peg$currPos < input.length) {
			peg$fail(peg$endExpectation());
		}

		throw peg$buildStructuredError(
			peg$maxFailExpected,
			peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
			peg$maxFailPos < input.length
				? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
				: peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
		);
	}
}

export interface ParseOptions {
	filename?: string;
	startRule?: string;
	tracer?: any;
	[key: string]: any;
}
export type ParseFunction = (input: string, options?: ParseOptions) => any;
export const parse: ParseFunction = peg$parse;
